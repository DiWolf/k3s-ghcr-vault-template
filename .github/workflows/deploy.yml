name: Deploy

# ─────────────────────────────────────────────────────────────────
# ANTES DE USAR ESTE WORKFLOW — LEE SETUP.md
#
# Placeholders a reemplazar:
#   APP_NAME        → nombre del deployment en k8s (minúsculas)
#   CONTAINER_NAME  → spec.template.spec.containers[0].name en deployment.yaml
#
# GitHub Secrets requeridos:
#   K8S_SSH_KEY     → clave privada SSH para acceder al nodo k3s
#   K8S_HOST        → IP o hostname del nodo k3s
#
# Ajuste para Proxmox (opcional):
#   Si k3s corre dentro de un contenedor Proxmox (LXC/CT), reemplaza
#   los comandos kubectl por:
#     pct exec CT_ID -- bash -c "KUBECONFIG=/etc/rancher/k3s/k3s.yaml kubectl ..."
# ─────────────────────────────────────────────────────────────────

on:
  push:
    branches:
      - development  # → QA   (⚠️ no es 'develop' — ver SETUP.md §1.2)
      - main         # → PROD

env:
  REGISTRY: ghcr.io

# GITHUB_TOKEN necesita write:packages para GHCR y read:packages para el pull secret
permissions:
  contents: read
  packages: write

jobs:
  # ─────────────────────────────────────────────
  # 1. BUILD & PUSH → GHCR
  # ─────────────────────────────────────────────
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      sha_short:  ${{ steps.vars.outputs.sha_short }}
      image_name: ${{ steps.vars.outputs.image_name }}

    steps:
      - uses: actions/checkout@v4

      # ⚠️ Convierte el nombre del repo a minúsculas.
      #    github.repository puede tener mayúsculas (ej: User/My-App).
      #    GHCR y k8s exigen lowercase — sin esto obtienes InvalidImageName.
      - name: Set vars (lowercase image name + short SHA)
        id: vars
        run: |
          echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "image_name=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      # Requerido para cache type=gha
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ steps.vars.outputs.image_name }}
          tags: |
            type=sha,prefix=sha-
            type=ref,event=branch

      - name: Build & push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags:   ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to:   type=gha,mode=max

  # ─────────────────────────────────────────────
  # 2. DEPLOY → QA
  # ─────────────────────────────────────────────
  deploy-qa:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/development'
    environment: qa

    steps:
      # ⚠️ Rota el pull secret de GHCR usando GITHUB_TOKEN del workflow.
      #    GITHUB_TOKEN tiene read:packages automáticamente para el paquete del repo.
      #    No uses gh auth token ni un PAT aleatorio — pueden no tener el scope correcto.
      - name: Refresh GHCR pull secret in QA namespace
        uses: appleboy/ssh-action@v1.0.3
        with:
          host:     ${{ secrets.K8S_HOST }}
          username: ${{ secrets.K8S_USER }}
          key:      ${{ secrets.K8S_SSH_KEY }}
          script: |
            kubectl create secret docker-registry ghcr-credentials \
              --docker-server=ghcr.io \
              --docker-username=${{ github.actor }} \
              --docker-password=${{ secrets.GITHUB_TOKEN }} \
              --namespace=qa \
              --dry-run=client -o yaml | kubectl apply -f -

      # ⚠️ Define IMAGE antes del comando kubectl para que la variable
      #    se expanda en el shell correcto y no llegue literal a kubectl.
      #    Ver SETUP.md sección "Variable no expandida en subshell anidado".
      - name: Deploy image to QA
        uses: appleboy/ssh-action@v1.0.3
        with:
          host:     ${{ secrets.K8S_HOST }}
          username: ${{ secrets.K8S_USER }}
          key:      ${{ secrets.K8S_SSH_KEY }}
          script: |
            set -e
            IMAGE="ghcr.io/${{ needs.build-and-push.outputs.image_name }}:sha-${{ needs.build-and-push.outputs.sha_short }}"
            kubectl set image deployment/APP_NAME CONTAINER_NAME=${IMAGE} -n qa
            kubectl rollout status deployment/APP_NAME -n qa --timeout=120s

  # ─────────────────────────────────────────────
  # 3. DEPLOY → PROD
  # ─────────────────────────────────────────────
  deploy-prod:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: prod   # aprobación manual en GitHub → Settings → Environments

    steps:
      - name: Refresh GHCR pull secret in PROD namespace
        uses: appleboy/ssh-action@v1.0.3
        with:
          host:     ${{ secrets.K8S_HOST }}
          username: ${{ secrets.K8S_USER }}
          key:      ${{ secrets.K8S_SSH_KEY }}
          script: |
            kubectl create secret docker-registry ghcr-credentials \
              --docker-server=ghcr.io \
              --docker-username=${{ github.actor }} \
              --docker-password=${{ secrets.GITHUB_TOKEN }} \
              --namespace=prod \
              --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy image to PROD
        uses: appleboy/ssh-action@v1.0.3
        with:
          host:     ${{ secrets.K8S_HOST }}
          username: ${{ secrets.K8S_USER }}
          key:      ${{ secrets.K8S_SSH_KEY }}
          script: |
            set -e
            IMAGE="ghcr.io/${{ needs.build-and-push.outputs.image_name }}:sha-${{ needs.build-and-push.outputs.sha_short }}"
            kubectl set image deployment/APP_NAME CONTAINER_NAME=${IMAGE} -n prod
            kubectl rollout status deployment/APP_NAME -n prod --timeout=120s
